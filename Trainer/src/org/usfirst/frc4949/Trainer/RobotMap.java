// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc4949.Trainer;
import edu.wpi.first.wpilibj.ADXRS450_Gyro;
import edu.wpi.first.wpilibj.Counter;
import edu.wpi.first.wpilibj.I2C;
import edu.wpi.first.wpilibj.PIDSourceType;

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import com.ctre.CANTalon;
import edu.wpi.first.wpilibj.PowerDistributionPanel;
import edu.wpi.first.wpilibj.RobotDrive;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import edu.wpi.first.wpilibj.livewindow.LiveWindow;

/**
 * The RobotMap is a mapping from the ports sensors and actuators are wired into
 * to a variable name. This provides flexibility changing wiring, makes checking
 * the wiring easier and significantly reduces the number of magic numbers
 * floating around.
 */
public class RobotMap {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    public static CANTalon drivelrController;
    public static CANTalon driverrController;
    public static CANTalon driverfController;
    public static CANTalon drivelfController;
    public static RobotDrive driveRobotDrive;
    public static PowerDistributionPanel powerPDP;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    public static ADXRS450_Gyro driveADXRS450_Gyro;
    public static Counter driverfEncoder;
    public static Counter driverrEncoder;
    public static Counter drivelfEncoder;
    public static Counter drivelrEncoder;
    public static I2C arduinoPort;

    public static void init() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
        drivelrController = new CANTalon(2);
        LiveWindow.addActuator("Drive", "lrController", drivelrController);
        
        driverrController = new CANTalon(1);
        LiveWindow.addActuator("Drive", "rrController", driverrController);
        
        driverfController = new CANTalon(0);
        LiveWindow.addActuator("Drive", "rfController", driverfController);
        
        drivelfController = new CANTalon(3);
        LiveWindow.addActuator("Drive", "lfController", drivelfController);
        
        driveRobotDrive = new RobotDrive(drivelfController, drivelrController,
              driverfController, driverrController);
        
        driveRobotDrive.setSafetyEnabled(true);
        driveRobotDrive.setExpiration(0.5);
        driveRobotDrive.setSensitivity(0.5);
        driveRobotDrive.setMaxOutput(1.0);

        driveRobotDrive.setInvertedMotor(RobotDrive.MotorType.kFrontRight, true);
        driveRobotDrive.setInvertedMotor(RobotDrive.MotorType.kRearRight, true);
        powerPDP = new PowerDistributionPanel(0);
        LiveWindow.addSensor("Power", "PDP", powerPDP);
        

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
        /**
         * The touchless encoders are actually unidirectional counters.
         * 
         * There are a few different parameters that can be set to control 
         * various aspects of the counter behavior:
         * 
         * Max Period - The maximum period (in seconds) where the device is 
         * still considered moving. This value is used to determine the state 
         * of the getStopped() method and effect the output of the getPeriod() 
         * and getRate() methods.
         * 
         * Update When Empty - Setting this to false will keep the most recent 
         * period on the counter when the counter is determined to be stalled 
         * (based on the Max Period described above). Setting this parameter to 
         * True will return 0 as the period of a stalled counter.
         * 
         * Reverse Direction - Valid in external direction mode only. Setting 
         * this parameter to true reverses the counting direction of the external 
         * direction mode of the counter.
         * 
         * Samples to Average - Sets the number of samples to average when 
         * determining the period. Averaging may be desired to account for 
         * mechanical imperfections (such as unevenly spaced reflectors when 
         * using a reflective sensor as an encoder) or as oversampling to 
         * increase resolution. Valid values are 1 to 127 samples.
         * 
         * Distance Per Pulse - Sets the multiplier used to determine distance 
         * from count when using the getDistance() method.  These counters should
         * be triggering on the lines painted on to the hubs. They all have 18 black 
         * marks, except for the left rear, which has only 16. The circumference
         * of the wheel is 31.4 cm. This should amount to 1.74444444 cm per pulse for
         * three of the encoders and 1.9625 cm per pulse for the reamining encoder.
         */
        
        driverfEncoder = new Counter(2);
        driverfEncoder.setMaxPeriod(.1);
        driverfEncoder.setUpdateWhenEmpty(true);
        driverfEncoder.setReverseDirection(false);
        driverfEncoder.setSamplesToAverage(6);
        driverfEncoder.setDistancePerPulse(3.5);
		driverfEncoder.setPIDSourceType(PIDSourceType.kDisplacement);
        LiveWindow.addActuator("Encoder", "Right Front", driverfEncoder);

        driverrEncoder = new Counter(3);
        driverrEncoder.setMaxPeriod(.1);
        driverrEncoder.setUpdateWhenEmpty(true);
        driverrEncoder.setReverseDirection(false);
        driverrEncoder.setSamplesToAverage(6);
        driverrEncoder.setDistancePerPulse(3.5);
		driverrEncoder.setPIDSourceType(PIDSourceType.kDisplacement);
        LiveWindow.addActuator("Encoder", "Right Rear", driverrEncoder);
        
        drivelfEncoder = new Counter(1);
        drivelfEncoder.setMaxPeriod(.1);
        drivelfEncoder.setUpdateWhenEmpty(true);
        drivelfEncoder.setReverseDirection(false);
        drivelfEncoder.setSamplesToAverage(6);
        drivelfEncoder.setDistancePerPulse(3.5);
		drivelfEncoder.setPIDSourceType(PIDSourceType.kDisplacement);
        LiveWindow.addActuator("Encoder", "Left Front", drivelfEncoder);

        drivelrEncoder = new Counter(0);
        drivelrEncoder.setMaxPeriod(.1);
        drivelrEncoder.setUpdateWhenEmpty(true);
        drivelrEncoder.setReverseDirection(false);
        drivelrEncoder.setSamplesToAverage(6);
        drivelrEncoder.setDistancePerPulse(3.5);
		drivelrEncoder.setPIDSourceType(PIDSourceType.kDisplacement);
        LiveWindow.addActuator("Encoder", "Left Rear", drivelrEncoder);
        
        driveADXRS450_Gyro = new ADXRS450_Gyro();
        LiveWindow.addActuator("Gyro", "ADXRS450", driveADXRS450_Gyro);
        
        arduinoPort = new I2C(I2C.Port.kMXP, 0xA0);



    }
}
